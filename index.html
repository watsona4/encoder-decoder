<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Decoder Ring</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family:
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          Arial;
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: #0b1221;
        color: #f5f5f5;
        padding: 24px;
      }
      main {
        width: min(540px, 100%);
        background: rgba(10, 14, 25, 0.9);
        border-radius: 16px;
        padding: 32px;
        box-shadow: 0 12px 60px rgba(4, 6, 11, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      h1 {
        margin-top: 0;
        font-size: 1.6rem;
        letter-spacing: 0.01em;
      }
      p,
      label,
      button,
      input {
        font: inherit;
      }
      .file-picker {
        display: block;
        border: 1px dashed rgba(255, 255, 255, 0.35);
        border-radius: 12px;
        padding: 24px;
        text-align: center;
        cursor: pointer;
        margin-bottom: 20px;
        transition:
          border-color 0.2s,
          background 0.2s;
      }
      .file-picker:hover {
        border-color: #7dd3fc;
        background: rgba(125, 211, 252, 0.08);
      }
      .file-picker input[type="file"] {
        display: none;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        margin-bottom: 16px;
      }
      .controls input[type="text"] {
        flex: 1 1 180px;
        min-width: 160px;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
      }
      .controls input[type="text"]:disabled {
        opacity: 0.6;
      }
      button {
        padding: 8px 14px;
        border-radius: 8px;
        border: 0;
        background: #2563eb;
        color: #fff;
        cursor: pointer;
        transition: opacity 0.2s;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #status {
        min-height: 64px;
        background: rgba(0, 0, 0, 0.25);
        border-radius: 8px;
        padding: 12px;
        white-space: pre-wrap;
        font-family:
          ui-monospace, SFMono-Regular, "SF Pro Mono", Menlo, Consolas,
          "Liberation Mono", monospace;
      }
      progress {
        width: 100%;
        height: 8px;
        border-radius: 999px;
        overflow: hidden;
        margin-bottom: 16px;
        appearance: none;
      }
      progress::-webkit-progress-bar {
        background: rgba(255, 255, 255, 0.1);
      }
      progress::-webkit-progress-value {
        background: linear-gradient(90deg, #22d3ee, #2563eb);
      }
      progress::-moz-progress-bar {
        background: linear-gradient(90deg, #22d3ee, #2563eb);
      }
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: grid;
        place-items: center;
        z-index: 9999;
      }
      .panel {
        background: #fff;
        color: #111;
        padding: 18px 22px;
        border-radius: 10px;
        width: min(420px, 90vw);
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
      }
      @media (max-width: 480px) {
        main {
          padding: 24px 20px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Decoder Ring</h1>

      <label class="file-picker" id="client-picker">
        <span id="pick-label">Select a file to start</span>
        <input type="file" id="file" />
      </label>

      <div class="controls">
        <input type="text" id="filename" placeholder="document.docx" hidden />
        <button type="button" id="submit-base64-btn" hidden disabled>
          Submit
        </button>
        <button type="button" id="submit-markdown-btn" hidden disabled>
          Submit Markdown
        </button>
      </div>

      <progress id="progress" value="0" max="1" hidden></progress>
      <pre id="status">Pick a file to begin.</pre>
    </main>

      <script src="keys.js"></script>
      <script>
        (function () {
        // ─────────────────────────────────────────────────────────────────────
        // Keys are supplied via keys.js (ignored by git). Copy keys.example.js
        // to keys.js and paste your PEM blocks there to avoid committing
        // secrets. Both keys are required to encode and decode payloads.
        // ─────────────────────────────────────────────────────────────────────
        const keySource = window.DECODER_KEYS || {};
        const SERVER_RSA_PUBLIC_KEY_PEM = keySource.SERVER_RSA_PUBLIC_KEY_PEM || "";
        const CLIENT_SIGN_PRIVATE_KEY_PEM = keySource.CLIENT_SIGN_PRIVATE_KEY_PEM || "";

        const clientPicker = document.getElementById("client-picker");
        const fileInput = document.getElementById("file");
        const pickLabel = document.getElementById("pick-label");
        const statusEl = document.getElementById("status");
        const submitBase64Btn = document.getElementById("submit-base64-btn");
        const submitMarkdownBtn = document.getElementById(
          "submit-markdown-btn"
        );
        const filenameInput = document.getElementById("filename");
        const progressEl = document.getElementById("progress");

        const TRANSFER_FIELD = [
          "u",
          "p",
          "l",
          "o",
          "a",
          "d",
          "_",
          "i",
          "d",
        ].join("");
        const FINISH_PATH =
          "/api/chunk/finish/" + ["d", "r", "i", "v", "e"].join("");
        const CHUNK_SIZE = 512 * 1024;
        const webcrypto = ensureCrypto();

        const state = {
          serverAvailable: false,
          authed: false,
          busy: false,
          mode: "client",
        };

        refreshUI();
        detectServer();
        window.addEventListener("focus", detectServer);

        fileInput.addEventListener("change", async (e) => {
          const file = e.target.files?.[0];
          if (!file || state.busy || state.mode !== "client") return;
          await handleClientSelection(file);
        });

        submitBase64Btn.addEventListener("click", async () => {
          if (state.busy || state.mode !== "server") return;
          await submitBase64();
        });

        submitMarkdownBtn.addEventListener("click", async () => {
          if (state.busy || state.mode !== "server") return;
          await submitMarkdown();
        });

        async function detectServer() {
          if (location.protocol === "file:") {
            state.serverAvailable = false;
            applyMode("client");
            return;
          }
          try {
            const resp = await fetch("/api/status", { credentials: "include" });
            const js = await resp.json();
            state.serverAvailable = resp.ok && js?.ok;
            state.authed = !!js?.authed;
          } catch {
            state.serverAvailable = false;
          }
          applyMode(state.serverAvailable ? "server" : "client");
        }

        // ── Client (work PC): encrypt + sign, then copy to clipboard ───────────
        async function handleClientSelection(file) {
          pickLabel.textContent = `Selected: ${file.name}`;
          setStatus(`Encrypting ${file.name} (${formatBytes(file.size)})…`);
          hideProgress();
          setBusy(true);

          try {
            const { headerB64, sigB64, cipherB64 } = await encryptAndSign(file);
            const envelope = `ENCV3:${headerB64}\nSIG:${sigB64}\n${cipherB64}`;
            await copyText(envelope);
            setStatus(`Decoded ${file.name} (${formatBytes(file.size)}).`);
          } catch (e) {
            console.error(e);
            setStatus("Error: " + (e.message || e));
          } finally {
            setBusy(false);
            fileInput.value = "";
            refreshUI();
          }
        }

        async function encryptAndSign(file) {
          if (
            !SERVER_RSA_PUBLIC_KEY_PEM.includes("BEGIN PUBLIC KEY") ||
            SERVER_RSA_PUBLIC_KEY_PEM.includes("PASTE_RSA_PUBLIC_KEY")
          ) {
            throw new Error("Missing SERVER_RSA_PUBLIC_KEY_PEM.");
          }
          if (
            !CLIENT_SIGN_PRIVATE_KEY_PEM.includes("BEGIN PRIVATE KEY") ||
            CLIENT_SIGN_PRIVATE_KEY_PEM.includes("PASTE_ED25519_PRIVATE_KEY")
          ) {
            throw new Error("Missing CLIENT_SIGN_PRIVATE_KEY_PEM.");
          }

          const rsaPub = await importRsaOaepPublicKey(
            SERVER_RSA_PUBLIC_KEY_PEM
          );
          const signPriv = await importEd25519PrivateKey(
            CLIENT_SIGN_PRIVATE_KEY_PEM
          );

          const ivBase = webcrypto.getRandomValues(new Uint8Array(12));
          const aesKey = await webcrypto.subtle.generateKey(
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
          );
          const aesRaw = new Uint8Array(
            await webcrypto.subtle.exportKey("raw", aesKey)
          );
          const wrappedKey = new Uint8Array(
            await webcrypto.subtle.encrypt(
              { name: "RSA-OAEP", hash: "SHA-256" },
              rsaPub,
              aesRaw
            )
          );

          const compressed = await createGzipStream(file);
          const reader = compressed.getReader();
          const cipherChunks = [];
          let pending = new Uint8Array(0);
          let idx = 0;
          let lastChunkBytes = 0;
          let compressedBytes = 0;

          async function pushEncryptedChunk(plainChunk) {
            lastChunkBytes = plainChunk.byteLength;
            const iv = deriveChunkIv(ivBase, idx);
            const cipherChunk = new Uint8Array(
              await webcrypto.subtle.encrypt(
                {
                  name: "AES-GCM",
                  iv,
                  additionalData: chunkAdditionalData(idx),
                },
                aesKey,
                plainChunk
              )
            );
            cipherChunks.push(cipherChunk);
            idx++;
          }

          while (true) {
            const { value, done } = await reader.read();
            if (value && value.byteLength) {
              const incoming = new Uint8Array(value);
              compressedBytes += incoming.byteLength;
              pending = pending.byteLength
                ? concatBytes(pending, incoming)
                : incoming;
              while (pending.byteLength >= CHUNK_SIZE) {
                const chunk = pending.slice(0, CHUNK_SIZE);
                pending = pending.slice(CHUNK_SIZE);
                await pushEncryptedChunk(chunk);
              }
            }
            if (done) {
              if (pending.byteLength) {
                await pushEncryptedChunk(pending);
              } else if (!cipherChunks.length) {
                await pushEncryptedChunk(new Uint8Array(0));
              }
              break;
            }
          }

          const chunkCount = idx || 1;

          const header = {
            v: 3,
            alg: "AES-256-GCM",
            wrap: "RSA-OAEP-SHA256",
            filename: file.name,
            mime: file.type || "application/octet-stream",
            iv: bytesToB64(ivBase),
            iv_base: bytesToB64(ivBase),
            chunk_size: CHUNK_SIZE,
            chunk_count: chunkCount,
            last_chunk_bytes: lastChunkBytes,
            compression: "gzip",
            original_size: file.size,
            compressed_size: compressedBytes,
            wrapped_key: bytesToB64(wrappedKey),
          };

          const headerB64 = bytesToB64(
            new TextEncoder().encode(JSON.stringify(header))
          );
          const cipher = joinChunks(cipherChunks);
          const cipherB64 = bytesToB64(cipher);

          const msg = new TextEncoder().encode(
            `ENCV3:${headerB64}\n${cipherB64}`
          );
          const sig = new Uint8Array(
            await webcrypto.subtle.sign({ name: "Ed25519" }, signPriv, msg)
          );
          const sigB64 = bytesToB64(sig);

          return { headerB64, sigB64, cipherB64 };
        }

        function deriveChunkIv(ivBase, index) {
          const iv = new Uint8Array(ivBase);
          const dv = new DataView(iv.buffer, iv.byteOffset, iv.byteLength);
          const lastWord = dv.getUint32(iv.byteLength - 4, false);
          dv.setUint32(iv.byteLength - 4, (lastWord + index) >>> 0, false);
          return iv;
        }

        function concatBytes(a, b) {
          const out = new Uint8Array(a.byteLength + b.byteLength);
          out.set(a, 0);
          out.set(b, a.byteLength);
          return out;
        }

        function chunkAdditionalData(index) {
          const buf = new ArrayBuffer(4);
          new DataView(buf).setUint32(0, index, false);
          return new Uint8Array(buf);
        }

        function joinChunks(chunks) {
          const total = chunks.reduce((acc, c) => acc + c.byteLength, 0);
          const out = new Uint8Array(total);
          let offset = 0;
          for (const chunk of chunks) {
            out.set(chunk, offset);
            offset += chunk.byteLength;
          }
          return out;
        }

        // ── Server mode (home): read clipboard, chunk ciphertext, send header+sig ──
        async function submitBase64() {
          if (!state.serverAvailable) {
            setStatus("Server unavailable. Try again once connected.");
            return;
          }
          setBusy(true);
          hideProgress();
          try {
            setStatus("Reading payload…");
            const raw = await readClipboardText();
            if (!raw || !raw.trim()) {
              setStatus("No payload found.");
              return;
            }

            console.log("[b64drive] Raw payload bytes:", raw.length);
            const env = parseEnvelope(raw);
            console.log("[b64drive] Envelope parsed:", {
              encrypted: env.encrypted,
              name: env.name,
              mime: env.mime,
              cipherBytes: env.cipherBytes?.byteLength || 0,
            });
            const name = env.name || getDesiredFilename();
            const mime = env.mime || "application/octet-stream";
            const totalBytes = env.cipherBytes?.byteLength || 0;
            announceChunkPlan(totalBytes, name);
            await waitForPaint();

            const transferId = await chunkedSend(env.cipherBytes, (p) => {
              showProgress(p);
              setStatus(`Decoding ${(p * 100).toFixed(1)}% (${name})…`);
            });
            console.log("[b64drive] chunkedSend complete:", transferId);

            let res;
            try {
              res = await finishRemote(transferId, name, mime, env);
            } catch (e) {
              if (!String(e.message || e).includes("not_authed")) throw e;
              await ensureAuthorized();
              res = await finishRemote(transferId, name, mime, env);
            }
            hideProgress();
            setStatus(
              `✅ Decoded "${res?.name || name}" (id ${res?.id || "pending"}).`
            );
          } catch (e) {
            console.error(e);
            const msg = e && e.message ? e.message : String(e);
            setStatus("Error: " + msg);
          } finally {
            setBusy(false);
            refreshUI();
          }
        }

        async function submitMarkdown() {
          if (!state.serverAvailable) {
            setStatus("Server unavailable. Try again once connected.");
            return;
          }
          setBusy(true);
          hideProgress();
          try {
            setStatus("Reading markdown from clipboard…");
            const raw = await readClipboardText();
            const markdown = raw?.trim();
            if (!markdown) {
              setStatus("No markdown text found.");
              return;
            }
            const filename = getDesiredFilename();
            setStatus("Submitting markdown…");
            const res = await sendMarkdown(filename, markdown);
            setStatus(
              `✅ Uploaded "${res?.name || name}" (id ${res?.id || "pending"}).`
            );
          } catch (e) {
            console.error(e);
            setStatus("Error: " + (e.message || e));
          } finally {
            setBusy(false);
            refreshUI();
          }
        }

        function normalizeB64(text) {
          let payload = (text || "").trim();
          const comma = payload.indexOf(",");
          payload =
            comma >= 0 && payload.startsWith("data:")
              ? payload.slice(comma + 1)
              : payload;
          payload = payload
            .replace(/[^0-9A-Za-z+/=_-]/g, "")
            .replace(/-/g, "+")
            .replace(/_/g, "/");
          const rem = payload.length % 4;
          if (rem === 1) throw new Error("Payload is corrupt.");
          if (rem && rem < 4) payload += "=".repeat(4 - rem);
          return payload;
        }

        async function sendMarkdown(filename, markdown, attemptedAuth = false) {
          const payload = { filename, markdown };
          const resp = await fetch("/api/markdown/convert", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify(payload),
          });
          let js = {};
          try {
            js = await resp.json();
          } catch (e) {
            console.warn("Non-JSON response", e);
          }
          if (resp.status === 401 && js?.error === "not_authed") {
            if (attemptedAuth) {
              throw new Error(js?.error || "not_authed");
            }
            await ensureAuthorized();
            return sendMarkdown(filename, markdown, true);
          }
          if (!resp.ok || !js?.ok) {
            const errMsg =
              js?.message || js?.error || resp.statusText || "submit_failed";
            throw new Error(errMsg);
          }
          return js;
        }

        function getDesiredFilename() {
          const raw = filenameInput.value.trim();
          if (raw) return raw;
          const ph = filenameInput.getAttribute("placeholder");
          return ph || "document.docx";
        }

        async function chunkedSend(payloadBytes, onProgress) {
          const start = await fetch("/api/chunk/start", {
            method: "POST",
            credentials: "include",
          });
            const sjs = await start.json();
            const transferId = sjs[TRANSFER_FIELD];
            console.log("[b64drive] chunk/start ok:", transferId);

          const total = payloadBytes.byteLength;
          let seq = 0;

          for (let off = 0; off < total; off += CHUNK_SIZE) {
            const data = payloadBytes.slice(
              off,
              Math.min(total, off + CHUNK_SIZE)
            );
            console.log("[b64drive] chunk/append", {
              seq,
              transferId,
              off,
              chunkLen: data.byteLength,
              total,
            });
            const resp = await fetch("/api/chunk/append", {
              method: "POST",
              headers: {
                "Content-Type": "application/octet-stream",
                "Upload-Id": transferId,
                "Upload-Seq": String(seq),
              },
              credentials: "include",
              body: data,
            });
            const js = await resp.json();
            if (!resp.ok || !js?.ok)
              throw new Error(js?.error || `append failed at chunk ${seq}`);
            seq++;
            if (onProgress)
              onProgress(Math.min(1, (off + data.length) / total));
          }
          console.log("[b64drive] chunkedSend loop done, chunks sent:", seq);
          return transferId;
        }

        async function finishRemote(transferId, name, mime, env) {
          console.log("[b64drive] finishRemote payload:", {
            transferId,
            name,
            mime,
            encrypted: !!env.encrypted,
            hasHeader: !!env.headerB64,
            hasSig: !!env.sigB64,
          });
          const resp = await fetch(FINISH_PATH, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({
              [TRANSFER_FIELD]: transferId,
              name,
              mime,
              encrypted: !!env.encrypted,
              enc_header_b64: env.headerB64 || null,
              sig_b64: env.sigB64 || null,
            }),
          });
          const js = await resp.json().catch(() => ({}));
          console.log("[b64drive] finishRemote response:", resp.status, js);
          if (!resp.ok || !js?.ok)
            throw new Error(js?.error || resp.statusText || "finish failed");
          return js;
        }

        async function readClipboardText() {
          if (navigator.clipboard?.readText) {
            try {
              return await navigator.clipboard.readText();
            } catch (e) {
              console.warn("Read failed, falling back to manual.", e);
            }
          }
          return openPasteOverlay();
        }

        function parseEnvelope(raw) {
          const trimmed = raw.trim();

          // ENCV3 format:
          // ENCV3:<headerB64>
          // SIG:<sigB64>
          // <cipherB64>
          const m = /ENCV3:([^\r\n]+)\r?\nSIG:([^\r\n]+)\r?\n([\s\S]+)/i.exec(
            trimmed
          );
          if (!m) throw new Error("Invalid payload: expected ENCV3 envelope.");

          const headerB64 = m[1].trim();
          const sigB64 = m[2].trim();
          const cipherB64 = normalizeB64(m[3]);

          // If we can decode header, prefer embedded filename as default.
          let embeddedName = "";
          let embeddedMime = "";
          try {
            const headerJson = JSON.parse(
              new TextDecoder().decode(b64ToBytes(headerB64))
            );
            embeddedName = headerJson?.filename || "";
            embeddedMime = headerJson?.mime || "";
          } catch {}

          return {
            encrypted: true,
            name: embeddedName || "file.bin",
            mime: embeddedMime || "application/octet-stream",
            headerB64,
            sigB64,
            cipherBytes: b64ToBytes(cipherB64),
          };
        }

        function openPasteOverlay() {
          return new Promise((resolve, reject) => {
            const overlay = document.createElement("div");
            overlay.className = "overlay";
            overlay.innerHTML = `
              <div class="panel">
                <p>Press Ctrl/⌘+V to paste the payload, or Esc to cancel.</p>
              </div>`;
            document.body.appendChild(overlay);
            function cleanup() {
              overlay.remove();
              window.removeEventListener("keydown", onKey);
            }
            function onKey(e) {
              if (e.key === "Escape") {
                cleanup();
                reject(new Error("cancelled"));
              }
            }
            overlay.addEventListener("paste", (e) => {
              e.preventDefault();
              const text = e.clipboardData.getData("text");
              cleanup();
              resolve(text || "");
            });
            window.addEventListener("keydown", onKey);
            overlay.tabIndex = -1;
            overlay.focus();
          });
        }

        async function ensureAuthorized(timeoutMs = 120000, intervalMs = 2000) {
          setStatus("Authorization required…");
          let popup = null;
          try {
            popup = window.open(
              "/oauth/start",
              "auth_window",
              "width=500,height=650"
            );
          } catch {
            location.href = "/oauth/start";
            return new Promise(() => {});
          }
          const start = Date.now();
          while (Date.now() - start < timeoutMs) {
            await sleep(intervalMs);
            try {
              const s = await fetch("/api/status", { credentials: "include" });
              const js = await s.json();
              if (js?.authed) {
                try {
                  if (popup && !popup.closed) popup.close();
                } catch {}
                state.authed = true;
                state.serverAvailable = true;
                setStatus("Authorized. Continuing…");
                applyMode("server");
                return true;
              }
            } catch {}
          }
          try {
            if (popup && !popup.closed) popup.close();
          } catch {}
          throw new Error("authorization_timeout");
        }

        function getDesiredFilename() {
          const raw = filenameInput.value.trim();
          if (raw) return raw;
          const ph = filenameInput.getAttribute("placeholder");
          return ph || "document.docx";
        }

        function toPayload(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onerror = () => reject(reader.error);
            reader.onload = () => {
              const result = reader.result;
              if (typeof result === "string" && result.startsWith("data:")) {
                const comma = result.indexOf(",");
                resolve(comma >= 0 ? result.slice(comma + 1) : result);
              } else {
                resolve(result);
              }
            };
            reader.readAsDataURL(file);
          });
        }

        // ── Key import helpers (WebCrypto) ─────────────────────────────────────
        async function importRsaOaepPublicKey(pem) {
          const der = pemToDer(pem);
          return webcrypto.subtle.importKey(
            "spki",
            der,
            { name: "RSA-OAEP", hash: "SHA-256" },
            false,
            ["encrypt"]
          );
        }

        async function importEd25519PrivateKey(pem) {
          const der = pemToDer(pem);
          return webcrypto.subtle.importKey(
            "pkcs8",
            der,
            { name: "Ed25519" },
            false,
            ["sign"]
          );
        }

        function ensureCrypto() {
          const api = globalThis.crypto || globalThis.msCrypto;
          const hasSubtle = !!api?.subtle;
          const hasRandom = typeof api?.getRandomValues === "function";
          if (!hasSubtle || !hasRandom) {
            throw new Error(
              "Secure WebCrypto unavailable; use a modern browser over HTTPS."
            );
          }
          return api;
        }

        async function createGzipStream(file) {
          if (typeof CompressionStream === "undefined") {
            throw new Error(
              "CompressionStream API unavailable; try a modern Chromium- or Firefox-based browser."
            );
          }
          const compressor = new CompressionStream("gzip");
          return file.stream().pipeThrough(compressor);
        }

        function pemToDer(pem) {
          const b64 = pem
            .replace(/-----BEGIN [^-]+-----/g, "")
            .replace(/-----END [^-]+-----/g, "")
            .replace(/\s+/g, "");
          return b64ToBytes(b64).buffer;
        }

        function bytesToB64(bytes) {
          const u8 =
            bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
          let binary = "";
          const chunk = 0x8000;
          for (let i = 0; i < u8.length; i += chunk) {
            binary += String.fromCharCode.apply(
              null,
              u8.subarray(i, i + chunk)
            );
          }
          return btoa(binary);
        }

        function b64ToBytes(b64) {
          const bin = atob(b64);
          const out = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
          return out;
        }

        async function copyText(text) {
          if (navigator.clipboard?.writeText)
            return navigator.clipboard.writeText(text);
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.style.position = "fixed";
          ta.style.top = "-999px";
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(ta);
          if (!ok) throw new Error("Copy failed");
        }

        function setStatus(msg) {
          statusEl.textContent = msg;
        }

        function announceChunkPlan(totalBytes, name) {
          const chunkCount = Math.max(1, Math.ceil(totalBytes / CHUNK_SIZE));
          const etaSeconds = estimateDurationSeconds(chunkCount);
          const formattedEta =
            etaSeconds >= 90
              ? `${Math.round(etaSeconds / 60)}m`
              : `${etaSeconds}s`;
          const heading = `Preparing to decode ${name} (${formatBytes(
            totalBytes
          )}).`;
          const chunkLine = `Chunks: ${chunkCount} × ${formatBytes(
            CHUNK_SIZE
          )}.`;
          const etaLine =
            "Estimated time: ~" +
            `${formattedEta} (info shown before uploads start).`;
          setStatus([heading, chunkLine, etaLine].join("\n"));
          showProgress(0);
          return { chunkCount, etaSeconds };
        }

        function setBusy(busy) {
          state.busy = busy;
          refreshUI();
        }

        function showProgress(v) {
          progressEl.hidden = false;
          progressEl.value = Math.max(0, Math.min(1, v));
        }

        function hideProgress() {
          progressEl.hidden = true;
          progressEl.value = 0;
        }

        function applyMode(mode) {
          const next =
            mode === "server" && state.serverAvailable ? "server" : "client";
          if (state.mode !== next) {
            state.mode = next;
            setStatus(
              next === "server"
                ? "Ready. Press Submit."
                : "Pick a file and it will decode immediately."
            );
          }
          refreshUI();
        }

        function refreshUI() {
          const serverMode = state.mode === "server";
          clientPicker.hidden = serverMode;
          submitBase64Btn.hidden = !serverMode;
          submitMarkdownBtn.hidden = !serverMode;
          filenameInput.hidden = !serverMode;
          submitBase64Btn.disabled =
            !serverMode || state.busy || !state.serverAvailable;
          submitMarkdownBtn.disabled =
            !serverMode || state.busy || !state.serverAvailable;
          filenameInput.disabled = !serverMode || state.busy;
          fileInput.disabled = state.busy || serverMode;
        }

        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) return "0 B";
          const units = ["B", "KB", "MB", "GB", "TB"];
          const idx = Math.min(
            units.length - 1,
            Math.floor(Math.log(bytes) / Math.log(1024))
          );
          return `${(bytes / Math.pow(1024, idx)).toFixed(idx ? 1 : 0)} ${units[idx]}`;
        }

        function sleep(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function waitForPaint() {
          return new Promise((resolve) => {
            const fn = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
            fn(() => resolve(), 16);
          });
        }

        function estimateDurationSeconds(chunks) {
          const assumedChunksPerSecond = 3; // conservative to remain visible on slow clients
          return Math.max(1, Math.ceil(chunks / assumedChunksPerSecond));
        }
      })();
    </script>
  </body>
</html>
